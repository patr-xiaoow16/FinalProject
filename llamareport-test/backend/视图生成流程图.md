# 视图生成流程图框架

## 整体流程概览

```
用户查询
    ↓
API接口层 (query.py)
    ↓
RAG引擎查询
    ↓
获取文本答案 + 数据来源
    ↓
可视化判断分支
    ├─ 未启用可视化 → 直接返回文本答案
    └─ 启用可视化 → 进入可视化生成流程
        ↓
可视化生成流程 (VisualizationAgent)
    ↓
返回完整响应（文本 + 可视化配置）
```

---

## 详细流程步骤

### 阶段一：查询处理（API层）

**入口：** `/query/ask` 接口（`api/query.py` 第 **50行**）

1. **接收用户查询**（第62-67行）
   - 验证查询非空
   - 验证查询长度（≤1000字符）

2. **调用RAG引擎**（第72-73行）
   - 使用 `RAGEngine.query()` 执行查询
   - 获取文本答案（answer）
   - 获取数据来源（sources）
   - 获取增强查询（enhanced_query）

3. **判断是否启用可视化**（第99行）
   - 检查 `request.enable_visualization` 标志
   - 如果未启用 → 直接返回文本答案
   - 如果启用 → 进入可视化生成流程（第101-131行）
     - 创建 `VisualizationAgent` 实例
     - 调用 `generate_visualization()` 方法
     - 将可视化结果添加到响应中

---

### 阶段二：可视化生成（VisualizationAgent）

**入口：** `VisualizationAgent.generate_visualization()`

#### 步骤1：可视化需求分析
- **代码位置：** `agents/visualization_agent.py` 第 **270-334行**
- **方法：** `_analyze_visualization_need(query, answer) -> bool`
- **调用位置：** `generate_visualization()` 第 **77行**
- **判断逻辑：**
  1. **问题类型分类**（第289行）：调用 `_classify_question_type()` 识别问题类型
  2. **合规类过滤**（第292-294行）：如果是 `compliance` 类型 → 返回 `False`
  3. **关键词检测**（第300-308行）：检查查询中是否包含可视化关键词（趋势、对比、数据等）
  4. **数字检测**（第311行）：检查回答中是否包含数字
  5. **非数据类处理**（第317-321行）：
     - 对于 `conclusion`、`structure`、`process`、`risk`、`attitude`、`comparison` 类型
     - 只要回答长度 > 30 字符，就允许生成视图（即使没有数字）
  6. **数据类处理**（第324行）：需要满足（有可视化关键词或包含数字）且回答长度 > 50 字符
- **结果：**
  - `needs_viz = False` → 返回无可视化响应
  - `needs_viz = True` → 继续下一步

#### 步骤2：问题类型分类
- **代码位置：** `agents/visualization_agent.py` 第 **183-268行**
- **方法：** `_classify_question_type(query, answer) -> str`
- **调用位置：** 
  - `_analyze_visualization_need()` 第 **289行**
  - `generate_visualization()` 第 **87行**
- **分类策略（三层匹配）：**
  1. **第一步：特定模式匹配**（第199-219行，优先级最高）
     - 过程类模式：`'关键事件'`, `'时间轴'`, `'什么时候'` 等 → 返回 `'process'`
     - 风险类模式：`'哪些风险'`, `'存在风险'` 等 → 返回 `'risk'`
     - 结构类模式：`'什么结构'`, `'业务组成'`, `'靠什么'` 等 → 返回 `'structure'`
  2. **第二步：关键词评分**（第221-247行）
     - 遍历所有问题类型，使用 `QUESTION_TYPE_KEYWORDS`（来自 `visualization_examples.py`）
     - 评分规则：
       - 关键词在 query 中匹配 → +2 分
       - 关键词在 answer 中匹配 → +1 分
       - 示例问题相似度匹配 → +相似度 × 3 分
  3. **第三步：选择最高分类型**（第249-260行）
     - 找到得分最高的类型
     - 如果最高分 > 0，返回该类型；否则默认返回 `'data'`
- **依赖数据结构：**
  - `QUESTION_TYPE_KEYWORDS`（`visualization_examples.py` 第214行）：每种类型的关键词列表
  - `VIEW_RECOMMENDATION_MAP`（`visualization_examples.py` 第250行）：推荐图表和示例问题
- **返回类型：**
  - `data` - 数据类
  - `conclusion` - 核心结论类
  - `structure` - 结构描述类
  - `process` - 过程与变化类
  - `risk` - 风险与不确定性类
  - `attitude` - 态度与语气类
  - `comparison` - 跨年度对比类
  - `compliance` - 纯合规/事实类（已过滤）

#### 步骤3：数据提取
- **代码位置：** `agents/visualization_agent.py` 第 **336-636行**
- **方法：** `_extract_data_from_answer(query, answer, sources, question_type) -> Dict`
- **调用位置：** `generate_visualization()` 第 **91行**
- **三层提取策略：**
  1. **第一层：表格数据提取**（第355-363行）
     - **方法：** `_extract_data_from_table_sources()`（第815行开始）
     - **逻辑：** 优先从 `sources` 中查找表格数据（`document_type == 'table_data'`）
     - **如果成功：** 直接返回表格提取的数据
     - **如果失败：** 进入第二层
  2. **第二层：LLM文本提取**（第365-502行）
     - **构建提示词：** 根据问题类型添加示例指导
       - 时间轴类型：提取时间点和事件描述
       - 风险类型：提取风险名称、概率、影响程度
       - 结构类型：提取业务名称和占比
       - 桑基图类型：提取节点和连接数据
     - **调用LLM：** 使用 `self.llm.acomplete(prompt)` 提取数据
     - **解析JSON：** 从LLM响应中提取JSON格式数据
  3. **第三层：Fallback提取**（第523-634行）
     - **风险类Fallback：** `_extract_risks_fallback()`（第637行开始）
       - 使用正则表达式从文本中提取风险名称
       - 匹配多种格式：Markdown加粗、标题、编号列表等
     - **结构类Fallback：** `_extract_structure_fallback()`（第716行开始）
       - 从文本中提取业务名称列表
- **特殊处理逻辑：**
  - **风险类问题**（第523-572行）：
    - 如果 `data_type != 'risk_matrix'` 但有 `risks` 字段 → 自动修正
    - 如果没有 `risks` 字段但有 `labels` 和 `values` → 尝试构建风险数据
    - 如果提取失败 → 调用 `_extract_risks_fallback()`
  - **结构类问题**（第574-589行）：
    - 如果 `has_data=false` 或 `data_type=unknown` → 调用 `_extract_structure_fallback()`
  - **数据类型推断**（第591-600行）：
    - 如果 `data_type='unknown'` 但 `has_data=true` → 根据数据特征推断类型
- **输出格式：**
  ```python
  {
      "has_data": bool,           # 是否包含数据
      "data_type": str,           # 数据类型（time_series/comparison/distribution/risk_matrix/sankey等）
      "labels": List[str],        # 标签列表（年份、风险名称等）
      "values": List[float],     # 数值列表
      "series": Dict,            # 多系列数据（可选）
      "unit": str,               # 数值单位（元、%、亿元等）
      "time_period": str,        # 时间周期（可选）
      "risks": List[Dict],       # 风险数据（风险类问题）
      "nodes": Dict,             # 节点数据（桑基图）
      "links": Dict              # 连接数据（桑基图）
  }
  ```
- **结果判断：**
  - 如果 `has_data = False` → 返回无可视化响应
  - 如果 `has_data = True` → 继续下一步

#### 步骤4：图表类型推荐
- **代码位置：** `agents/visualization_agent.py` 第 **920-1060行**
- **方法：** `_recommend_chart_type(query, data, answer, question_type) -> ChartRecommendation`
- **调用位置：** `generate_visualization()` 第 **104行**
- **推荐策略（三层权重）：**
  1. **问题类型分析**（权重：40%，第966-994行）
     - 从 `VIEW_RECOMMENDATION_MAP` 获取推荐图表类型
     - 特殊处理：
       - 过程类（`process`）：优先推荐 `ChartType.LINE`（可用于时间轴）
       - 风险类（`risk`）：优先推荐 `ChartType.SCATTER`（风险矩阵）
       - 数据类：根据 `data_type` 匹配（`time_series` → `LINE`，`comparison` → `BAR`，`distribution` → `PIE`）
  2. **数据类型分析**（权重：25%，第996-1005行）
     - 类型映射表：
       - `time_series` → `ChartType.LINE`
       - `comparison` → `ChartType.BAR`
       - `distribution` → `ChartType.PIE`
       - `single_value` → `ChartType.GAUGE`
       - `table` → `ChartType.TABLE`
  3. **综合推荐**（第1007-1008行）
     - 优先使用问题类型推荐，如果没有则使用数据类型推荐
- **特殊处理：**
  - **风险矩阵数据**（第956-964行）：如果 `data_type == 'risk_matrix'` 且 `question_type == 'risk'`
    - 直接推荐 `ChartType.SCATTER`（散点图）
    - 备选：`ChartType.HEATMAP`（热力图）
- **辅助方法：**
  - `_get_visualization_example()`（第1062-1115行）：根据问题类型和图表类型获取可视化示例
- **返回结果：**
  - `recommended_chart_type`: 主要图表类型（LINE/BAR/PIE等）
  - `reason`: 推荐理由（结合问题类型描述和数据类型）
  - `data_characteristics`: 数据特征描述
  - `alternative_charts`: 备选图表类型列表（最多3个）

#### 步骤5：特殊视图检查（时间轴）
- **代码位置：** `agents/visualization_agent.py` 第 **111-138行**
- **时间轴生成器：** `agents/timeline_generator.py` 第 **36-170行**
- **方法：** `generate_timeline_data(llm, query, answer, data, sources) -> List[Dict]`
- **调用位置：** `generate_visualization()` 第 **123行**
- **检查逻辑：**
  1. **条件判断**（第116行）：`if question_type == 'process'`
  2. **获取示例**（第118行）：调用 `_get_visualization_example()` 获取时间轴示例
  3. **示例匹配**（第120行）：检查示例类型是否为 `'timeline'`
- **如果匹配（第120-134行）：**
  - 调用 `generate_timeline_data()` 生成时间轴数据
  - **时间轴生成流程：**
    1. **构建提示词**（第60-108行）：包含时间轴组件代码示例作为先验知识
    2. **调用LLM**（第109行）：使用 `llm.acomplete(prompt)` 生成时间轴数据
    3. **解析和验证**（第110-158行）：
       - 清理响应文本（移除代码块标记）
       - 解析JSON
       - 验证数据格式（确保每个项包含 `time` 和 `content`）
       - 自动补充 `color` 字段（如果缺失）
    4. **格式化时间**（第145行）：调用 `_format_timeline_time()` 统一时间格式
    5. **按时间排序**（第149行）：调用 `_sort_timeline_by_time()` 排序
  - 设置 `visualization_type = "timeline"`
  - 设置 `chart_config = None`（避免前端同时渲染Plotly图表）
  - 更新推荐信息，说明使用时间轴
- **如果不匹配（第135-138行）：**
  - 继续使用Plotly图表
  - 设置 `visualization_type = "plotly"`
- **时间轴数据格式：**
  ```python
  [
      {
          "time": "2024",           # 时间点（简化格式）
          "content": "事件描述",     # 事件内容
          "color": "blue"           # 颜色（blue/green/red/gray/orange/purple）
      },
      ...
  ]
  ```

#### 步骤6：图表配置生成
- **代码位置：** `agents/visualization_agent.py` 第 **140-149行**（调用）和第 **1199-1587行**（实现）
- **方法：** `_generate_chart_config(chart_type, data, query, question_type, example) -> PlotlyChartConfig`
- **调用位置：** `generate_visualization()` 第 **144行**
- **条件判断：** `if visualization_type == "plotly"`（第143行）
- **生成流程：**
  1. **数据准备**（第1219-1223行）
     - 提取数据字段：`data_type`, `labels`, `values`, `unit`, `risks`
  2. **特殊处理 - 风险矩阵**（第1225-1267行）
     - 如果 `data_type == 'risk_matrix'` 且有风险数据
     - 获取风险矩阵示例，创建散点图轨迹和布局
  3. **获取可视化示例**（第1269-1274行）
     - 根据问题类型和图表类型获取示例，用于指导配置生成
  4. **生成标题**（第1277行）
     - 调用 `_generate_chart_title()`（第1589-1616行）生成图表标题
  5. **特殊处理 - 桑基图**（第1279-1356行）
     - 如果示例是桑基图，从数据中提取或构建 `nodes` 和 `links`
     - 创建 Sankey trace 和特殊配置
  6. **根据图表类型生成配置**（第1358-1534行）
     - **柱状图（BAR）**（第1359-1381行）：创建柱状图轨迹，包含标记颜色、文本位置
     - **折线图（LINE）**（第1383-1417行）：创建折线图轨迹，支持峰值标记
     - **饼图（PIE）**（第1419-1432行）：创建饼图轨迹，包含标签和悬停模板
     - **风险矩阵（SCATTER）**（第1434-1469行）：使用散点图展示风险矩阵
     - **桑基图（Sankey）**（第1471-1525行）：从数据中提取或构建节点和连接
     - **默认处理**（第1527-1534行）：默认使用柱状图
  7. **创建布局**（第1536-1573行）
     - 设置轴标题（从数据或示例中获取）
     - 设置图表高度、模板、悬停模式等
  8. **返回配置**（第1574-1578行）
     - 返回 `PlotlyChartConfig` 对象
- **支持的图表类型：**
  - 柱状图（BAR）
  - 折线图（LINE）
  - 饼图（PIE）
  - 散点图（SCATTER）- 用于风险矩阵
  - 桑基图（Sankey）- 用于业务结构
  - 热力图（HEATMAP）- 部分支持
- **关键特性：**
  - 示例驱动：优先使用可视化示例指导配置生成
  - 特殊处理：针对风险矩阵、桑基图等特殊图表类型
  - 自适应：根据数据类型自动选择最合适的图表类型
  - 样式统一：使用示例中的样式配置（颜色、标记等）
- **输出：** `PlotlyChartConfig` 对象，包含：
  - `chart_type`: 图表类型枚举
  - `traces`: 数据轨迹列表（`List[ChartTrace]`）
  - `layout`: 布局配置（`ChartLayout`）
  - `config`: 特殊配置（如 Sankey 数据）

#### 步骤7：洞察生成
- **代码位置：** `agents/visualization_agent.py` 第 **1618行开始**
- **方法：** `_generate_insights(data, chart_type) -> List[VisualizationInsight]`
- **调用位置：** `generate_visualization()` 第 **156行**
- **输入：**
  - 提取的数据（`extracted_data`）
  - 图表类型（`recommendation.recommended_chart_type`）
- **生成内容：**
  - 数据洞察（趋势、异常、关键点）
  - 业务洞察（业务含义、影响）
  - 可视化建议（如何解读图表）
- **输出：** `List[VisualizationInsight]`，每个洞察包含：
  - `type`: 洞察类型
  - `title`: 洞察标题
  - `description`: 洞察描述
  - `confidence`: 置信度

#### 步骤8：组装响应
- **代码位置：** `agents/visualization_agent.py` 第 **163-173行**
- **返回：** `VisualizationResponse` 对象（Pydantic模型）
- **包含字段：**
  - `query`: 用户查询
  - `answer`: 文本答案
  - `has_visualization`: 是否有可视化（`True`）
  - `chart_config`: Plotly图表配置（`PlotlyChartConfig` 或 `None`，Timeline类型时为None）
  - `timeline_data`: 时间轴数据（`List[Dict]` 或 `None`，仅Timeline类型时有值）
  - `visualization_type`: 可视化类型（`"plotly"` 或 `"timeline"`）
  - `recommendation`: 图表推荐信息（`ChartRecommendation`）
  - `insights`: 洞察列表（`List[VisualizationInsight]`）
  - `confidence_score`: 置信度分数（默认 `0.85`）
- **数据模型：** `models/visualization_models.py` 第 **161行开始**

---

### 阶段三：响应返回（API层）

1. **组装最终响应**
   - 基础字段（question、answer、sources）
   - 可视化数据（从VisualizationAgent获取）
   - 错误处理（如果可视化生成失败）

2. **返回JSON响应**
   - 状态码：200（成功）或500（错误）
   - 内容：包含文本答案和可视化配置的完整响应

---

## 关键决策点

### 决策点1：是否需要可视化？
- **判断位置：** 步骤1（可视化需求分析）
- **判断标准：** 查询关键词 + 答案内容特征
- **结果：** 是/否

### 决策点2：问题类型是什么？
- **判断位置：** 步骤2（问题类型分类）
- **判断标准：** 关键词匹配 + 语义分析
- **结果：** 8种类型之一

### 决策点3：能否提取数据？
- **判断位置：** 步骤3（数据提取）
- **判断标准：** LLM提取结果 + 数据验证
- **结果：** 有数据/无数据

### 决策点4：是否需要时间轴？
- **判断位置：** 步骤5（特殊视图检查）
- **判断标准：** 问题类型 = process + 示例匹配
- **结果：** Timeline视图 / Plotly视图

### 决策点5：使用哪种图表类型？
- **判断位置：** 步骤4（图表类型推荐）+ 步骤6（图表配置生成）
- **判断标准：** 问题类型 + 数据特征 + 示例库
- **结果：** LINE/BAR/PIE/TABLE等

---

## 数据流转

```
用户查询 (str)
    ↓
RAG查询结果
    ├─ answer (str)
    ├─ sources (List[Dict])
    └─ enhanced_query (str)
    ↓
VisualizationAgent输入
    ├─ query (str)
    ├─ answer (str)
    └─ sources (List[Dict])
    ↓
内部处理
    ├─ question_type (str)
    ├─ extracted_data (Dict)
    ├─ recommendation (ChartRecommendation)
    ├─ chart_config (PlotlyChartConfig | None)
    ├─ timeline_data (List[Dict] | None)
    └─ insights (List[VisualizationInsight])
    ↓
VisualizationResponse (Pydantic Model)
    ↓
JSON响应 (Dict)
    ↓
前端渲染
```

---

## 异常处理

### 异常点1：RAG查询失败
- **处理：** 返回错误响应，不进入可视化流程

### 异常点2：可视化需求分析失败
- **处理：** 返回无可视化响应（has_visualization=False）

### 异常点3：数据提取失败
- **处理：** 返回无可视化响应（has_visualization=False）

### 异常点4：图表配置生成失败
- **处理：** 捕获异常，返回无可视化响应，记录错误日志

### 异常点5：时间轴生成失败
- **处理：** 降级为Plotly折线图，记录警告日志

---

## 关键组件依赖

- **RAGEngine** (`core/rag_engine.py`): 提供文本答案和数据来源
- **VisualizationAgent** (`agents/visualization_agent.py`): 核心可视化生成逻辑
  - 主入口：`generate_visualization()` 方法（第54行）
  - 包含8个步骤的完整实现
- **TimelineGenerator** (`agents/timeline_generator.py`): 时间轴数据生成（可选）
  - 方法：`generate_timeline_data()`（第36行）
- **visualization_examples.py** (`agents/visualization_examples.py`): 可视化示例库和推荐规则
  - `VISUALIZATION_EXAMPLES`: 可视化示例库（第17行）
  - `QUESTION_TYPE_KEYWORDS`: 问题类型关键词（第214行）
  - `VIEW_RECOMMENDATION_MAP`: 视图推荐映射表（第250行）
- **visualization_models.py** (`models/visualization_models.py`): 数据模型定义（Pydantic）
  - `VisualizationResponse`: 可视化响应模型（第161行）
  - `ChartRecommendation`: 图表推荐模型
  - `PlotlyChartConfig`: Plotly图表配置模型
  - `VisualizationInsight`: 可视化洞察模型

---

## 性能优化点

1. **缓存机制：** 相同查询可缓存可视化结果
2. **异步处理：** 所有LLM调用均为异步
3. **早期退出：** 多个判断点可提前退出，避免不必要的处理
4. **示例匹配：** 优先使用示例库，减少LLM调用

